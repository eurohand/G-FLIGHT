<!DOCTYPE HTML>
<html>
<head>
<title>G FLIGHT - Data Structure Project</title>
</head>
<body>
<canvas id = "canvas" width = "1500" height = "700"></canvas>
<style>
  @import url('https://fonts.googleapis.com/css?family=VT323&display=swap');
</style>
<script>


	//constant variables---------------------------------------------------------------------------------------------------------
	
	const canvas = document.getElementById("canvas");
	const ctx = canvas.getContext("2d");
	const width = canvas.width;
	const height = canvas.height;
	const BODY = document.querySelector('body');
	const SHIP_SIZE = 30;
	const SHOOT_SIZE = 4;
	const ENEMY_SIZE = 40;
	const PORTION_SIZE = 6;
	const IMG_SIZE = 75;
	const FONT_NAME = 'VT323';
	const IMG_SRC = 'https://lh3.googleusercontent.com/Zupg6_TMI0uRGRYQEVJ9ULDslHDG4TSIf1fmQ4zeIoL-cUbMe_lOoYjJoih5LjIARw';
	
	
	
	
	//basic function-------------------------------------------------------------------------------------------------------------
	
	function drawLoading(){
		
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		ctx.font = "30px Courier";
		ctx.fillStyle = "Navy";
		ctx.drawImage(gachonImg, width-100, 25, IMG_SIZE, IMG_SIZE);	
		ctx.fillStyle = "White";
		ctx.font = `150px "${FONT_NAME}"`;
		ctx.fillText("G-flight", width*0.5, height*0.3);
		arrow.draw();
		ctx.font = `50px "${FONT_NAME}"`;
		ctx.fillText("   INSERT COIN", 750, 375);
		ctx.font = `20px "${FONT_NAME}"`;
		ctx.fillText("201635839 RHEE EURO", 750, 450);
		ctx.fillText("201532749 LEE JAEYOON", 750, 475);
		ctx.fillText("201635827 OH TAEHO", 750, 500);
		ctx.fillText("201635824 YEO JUNKU", 750, 525);
		ctx.fillStyle = "Black";
	}
	
	function drawBorder() {
		ctx.fillStyle = "Gray";
		ctx.fillRect(0, 0, width, 10);
		ctx.fillRect(0, height-10, width, 10);
		ctx.fillRect(0, 0, 10, height);
		ctx.fillRect(width-10, 0, 10, height);
	}
	
	function gameOver() {
		clearInterval(intervalId);
		ctx.font = "30px Courier";
		ctx.fillStyle =  "White";
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		ctx.fillText("Game Over", width/2, height/2);
	}
	
	function drawScore() {
		ctx.textAlign = "left";
		ctx.textBaseline = "top";
		ctx.font = "15px Courier";
		ctx.fillStyle = "Gray";
		ctx.fillText("W: move up, A: move left, S: move down, D: move right, click: shoot, space: ult", 15, 15);
		ctx.font = "20px Courier";
		ctx.fillStyle = "White";	
		ctx.fillText("Score : " + score, 15, 35);
		ctx.fillStyle = "Gray"
		ctx.fillRect(15, 60, 110, 40);
		ctx.fillStyle = "Red";
		ctx.fillRect(20, 65, ship.hp, 10);
		ctx.fillStyle = "Blue";
		ctx.fillRect(20, 85, ship.mp, 10);
	};
	
	function circle(x, y, r){
		ctx.beginPath();
		ctx.arc(x, y, r, 0, Math.PI*2, false);
		ctx.closePath();
	}
	
	let random = (number) => Math.floor(Math.random() * number);
	let plusminus = () => (random(2) === 0)? 1 : -1;
	
	//arrow----------------------------------------------------------------------------------------------------------------------
	let Arrow = function(){
		this.r = 15;
		this.updown = true;
	}
	
	Arrow.prototype.draw = function(){
		ctx.strokeStyle = "White";
		ctx.beginPath();
		ctx.moveTo(650, 375);
		ctx.lineTo(620, 375 + this.r);
		ctx.lineTo(620, 375 - this.r);
		ctx.closePath();
		ctx.fill();
		if(this.r >= 15 || this.r <= 0){
			this.updown = !this.updown;
		}
		if(this.updown){
			this.r += 2;
		}else{
			this.r -= 2;
		}
	}
	
	//quad tree------------------------------------------------------------------------------------------------------------------
	let Rectangle = function(x, y, w, h){
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
	}
	
	Rectangle.prototype.contains = function(point){
		return (point.x >= this.x - this.w
				&& point.x <= this.x + this.w 
				&& point.y >= this.y - this.h
				&& point.y <= this.y + this.h);
	}
	
	let QuadTree = function (boundary, n){
		this.boundary = boundary;
		this.capacity = n;
		this.points = [];
		this.divided = false;
	}
	
	QuadTree.prototype.subdivide = function(){
		let x = this.boundary.x;
		let y = this.boundary.y;
		let w = this.boundary.w;
		let h = this.boundary.h;
		
		let ne = new Rectangle(x + w/2, y - h/2, w/2, h/2);
		this.northeast = new QuadTree(ne, this.capacity);
		let nw = new Rectangle(x - w/2, y - h/2, w/2, h/2);
		this.northwest = new QuadTree(nw, this.capacity);
		let se = new Rectangle(x + w/2, y + h/2, w/2, h/2);
		this.southeast = new QuadTree(se, this.capacity);
		let sw = new Rectangle(x - w/2, y + h/2, w/2, h/2);
		this.southwest = new QuadTree(sw, this.capacity);
	}
	
	QuadTree.prototype.insert = function(point){
		if(!this.boundary.contains(point)){
			return;
		}
		
		if(this.points.length < this.capacity){
			this.points.push(point);
		} else{
			if(!this.divided){
				this.subdivide();
				this.divided = true;
			}
			this.northeast.insert(point);
			this.northwest.insert(point);
			this.southeast.insert(point);
			this.southwest.insert(point);	
		}
	}
	
	QuadTree.prototype.show = function(){
		ctx.lineWidth = 1;
		ctx.strokeStyle = "lime";
		ctx.strokeRect(this.boundary.x-this.boundary.w, this.boundary.y-this.boundary.h, this.boundary.w*2, this.boundary.h*2);
		if(this.divided){
			this.northeast.show();
			this.northwest.show();
			this.southeast.show();
			this.southwest.show();
		}
	}
	
	QuadTree.prototype.refresh = function(){
		shipShoots.forEach((shoot) => this.insert(shoot));
		enemies.forEach((enemy) => this.insert(enemy));
		portions.forEach((portion) => this.insert(portion));
	}
	
	
	
	//ship object----------------------------------------------------------------------------------------------------------------
	
	let Ship = function (x, y){
		this.x = x;
		this.y = y;
		
		this.xSpeed = 0;
		this.ySpeed = 0;
		
		this.r = SHIP_SIZE / 2;
		this.sin = -1;
		this.cos = 0;
		
		this.hp = 100;
		this.mp = 100;
	}
	
	Ship.prototype.move = function() {
		this.x += this.xSpeed;
		this.y += this.ySpeed;
		if(this.x < 20){
			this.x = 20;
		}
		if(this.x > width-20){
			this.x = width-20;
		}
		if(this.y < 40) {
			this.y = 40;
		}
		if(this.y > height-40){
			this.y = height-40;
		}
	}
	
	Ship.prototype.draw = function() {
		ctx.fillStyle = "White";
		ctx.strokeStyle = "White";
		ctx.lineWidth = this.r / 3;
        ctx.beginPath();
        ctx.moveTo( // nose of the ship
            ship.x + 4 / 3 * ship.r * this.cos,
            ship.y - 4 / 3 * ship.r * this.sin
        );
        ctx.lineTo( // rear left
            ship.x - ship.r * (2 / 3 * this.cos + this.sin),
            ship.y + ship.r * (2 / 3 * this.sin - this.cos)
        );
        ctx.lineTo( // rear right
            ship.x - ship.r * (2 / 3 * this.cos - this.sin),
            ship.y + ship.r * (2 / 3 * this.sin + this.cos)
        );
        ctx.closePath();
        ctx.stroke();
	}
	
	Ship.prototype.shoot = function() {	
		shipShoots.push(new Shoot(this.x, this.y, 50*this.cos, -50*this.sin, true));
	}
	
	Ship.prototype.setDirection = function(direction) {
		if(direction === "up"){
			this.ySpeed = -4;
		}else if(direction === "down"){
			this.ySpeed = 4;
		}else if(direction === "left"){
			this.xSpeed = -4;
		}else if(direction === "right"){
			this.xSpeed = 4;
		}else if (direction === "space"){
			if(this.mp >=100){
				this.skill();
				this.mp -=100;
			}
		}else if(direction === "quadtree"){
			if(quadtree){
				quadtree = false;
			}else{
				quadtree = true;
			}	
		}
	}
	
	Ship.prototype.checkCollision = function() {
		this.enemyCollision();
		this.shootCollision();
		this.portionCollision();
		if(this.hp <= 0){
			this.hp = 0;
			gameOver();
		}
	}
	
	Ship.prototype.enemyCollision = function() {
		let left = this.x - this.r;
		let right = this.x + this.r;
		let up = this.y - this.r;
		let down = this.y + this.r;
		
		enemies.forEach((enemy) => {
			if(left < enemy.x + enemy.w/2 &&
			right > enemy.x - enemy.w/2 &&
			up < enemy.y + enemy.h/2 &&
			down > enemy.y - enemy.h/2){
				this.hp -= 100;
			}
		});
	}
	
	Ship.prototype.shootCollision = function() {
		let left = this.x - this.r;
		let right = this.x + this.r;
		let up = this.y - this.r;
		let down = this.y + this.r;
		
		shipShoots.forEach((shoot) => {
			if(shoot.x > left && shoot.x < right && shoot.y > up && shoot.y < down && !shoot.my){
				this.hp -= 25;
				shipShoots.splice(shipShoots.indexOf(shoot), 1);
			}
		});
	}
	
	Ship.prototype.portionCollision = function(){
		let left = this.x - this.r;
		let right = this.x + this.r;
		let up = this.y - this.r;
		let down = this.y + this.r;
		
		portions.forEach((portion) => {
			if(portion.x > left && portion.x < right && portion.y > up && portion.y < down){
				this.hpPlus(25);
				booms.push(new Boom(this.x, this.y, "portion"));
				portions.splice(portions.indexOf(portion), 1);
				
			}
		});
	}
	
	Ship.prototype.skill = function() {
		for(var i=0 ; i<120 ; i++){
			shipShoots.push(new Shoot(this.x, this.y, 50*Math.cos(Math.PI/180*i*3), -50*Math.sin(Math.PI/180*i*3), true));
		}
	}
	
	Ship.prototype.mpPlus = function(amount){
		this.mp += amount;
		if(this.mp >= 100){
			this.mp = 100;
		}
	}
	
	Ship.prototype.hpPlus = function(amount){
		this.hp += amount;
		if(this.hp >= 100){
			this.hp = 100;
		}
	}
	
	
	
	
	
	//shoot object---------------------------------------------------------------------------------------------------------------
	
	var Shoot = function(x, y, xSpeed, ySpeed, my){
		this.x=x;
		this.y=y;
		this.xSpeed = xSpeed;
		this.ySpeed = ySpeed;
		this.r = SHOOT_SIZE / 2;
		this.use = true;
		this.my = my;
	}
	Shoot.prototype.draw = function(){
		if(this.my){
			ctx.fillStyle = "Cyan";
			ctx.fillRect(this.x-this.r, this.y-this.r, SHOOT_SIZE*1.3, SHOOT_SIZE*1.3);
		}else {
			ctx.fillStyle = "Orangered";
			ctx.fillRect(this.x-this.r, this.y-this.r, SHOOT_SIZE*1.8, SHOOT_SIZE*1.8);
		}
		
	}
	Shoot.prototype.move = function(){
		this.x += this.xSpeed;
		this.y += this.ySpeed;
		if(this.x > width || this.x < 0 || this.y > height || this.y < 0){
			this.use = false;
		}
	}
	
	
	
	
	
	//enemy objects--------------------------------------------------------------------------------------------------------------
	
	let Enemy = function(x, y, w, h, xSpeed, ySpeed, type) {
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
		this.xSpeed = xSpeed;
		this.ySpeed = ySpeed;
		this.type = type;
		this.count = 0;
		this.use = true;
	}
	
	Enemy.prototype.move = function() {
		this.x += this.xSpeed;
		this.y += this.ySpeed;
		this.count++;
		if(this.count >= 50){
			this.shoot();
			this.count = 0;
		}
	}
	
	Enemy.prototype.draw = function() {
		ctx.strokeStyle = "Black";
		let t;
		if(this.type === 0 || this.type === 2){
			t = -ENEMY_SIZE / 8;
		}else if(this.type === 1 || this.type === 3){
			t = ENEMY_SIZE / 8;
		}
		
		if(this.type === 0 || this.type === 1){
			ctx.lineWidth = 1;
			ctx.fillStyle="Pink";
			ctx.beginPath();
			ctx.moveTo(this.x, this.y-(t*8));
			ctx.lineTo(this.x-(t*3), this.y-(t*6));
			ctx.lineTo(this.x+(t*3), this.y-(t*6));
			ctx.lineTo(this.x, this.y-(t*8));
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
			
			ctx.fillStyle="Skyblue";
			ctx.beginPath();
			ctx.moveTo(this.x-(t*3), this.y-(t*6));
			ctx.lineTo(this.x-(t*3), this.y+(t*6));
			ctx.lineTo(this.x+(t*3), this.y+(t*6));
			ctx.lineTo(this.x+(t*3), this.y-(t*6));
			ctx.lineTo(this.x-(t*3), this.y-(t*6));
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
			
			ctx.fillStyle="Green";
			ctx.beginPath();
			ctx.moveTo(this.x-(t*3), this.y);
			ctx.lineTo(this.x-(t*5), this.y+(t*6));
			ctx.lineTo(this.x-(t*3), this.y+(t*6));
			ctx.lineTo(this.x-(t*3), this.y);
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
			
			ctx.beginPath();
			ctx.moveTo(this.x+(t*3), this.y);
			ctx.lineTo(this.x+(t*5), this.y+(t*6));
			ctx.lineTo(this.x+(t*3), this.y+(t*6));
			ctx.lineTo(this.x+(t*3), this.y);
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
		
			ctx.fillStyle="Red";
			ctx.beginPath();
			ctx.lineTo(this.x+(t*3), this.y+(t*6));
			ctx.lineTo(this.x+(t*3), this.y+(t*8));
			ctx.lineTo(this.x+(t*2), this.y+(t*7));
			ctx.lineTo(this.x+t, this.y+(t*8));
			ctx.lineTo(this.x, this.y+(t*7));
			ctx.lineTo(this.x-t, this.y+(t*8));
			ctx.lineTo(this.x-(t*2), this.y+(t*7));
			ctx.lineTo(this.x-(t*3), this.y+(t*8));
			ctx.lineTo(this.x-(t*3), this.y+(t*6));
			ctx.lineTo(this.x+(t*3), this.y+(t*6));
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
			
			ctx.fillStyle="Yellow";
			circle(this.x, this.y, Math.abs(t*2.4));
			ctx.fill();
			ctx.stroke();
			
			ctx.fillStyle="White";
			circle(this.x, this.y, Math.abs(t*1.4));
			ctx.fill();
			ctx.stroke();
		}else if(this.type === 2 || this.type === 3){
			ctx.lineWidth = 1;
			ctx.fillStyle="Pink";
			ctx.beginPath();
			ctx.moveTo(this.x-(t*8), this.y);
			ctx.lineTo(this.x-(t*6), this.y-(t*3));
			ctx.lineTo(this.x-(t*6), this.y+(t*3));
			ctx.lineTo(this.x-(t*8), this.y);
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
		
			ctx.fillStyle="Skyblue";
			ctx.beginPath();
			ctx.moveTo(this.x-(t*6), this.y-(t*3));
			ctx.lineTo(this.x+(t*6), this.y-(t*3));
			ctx.lineTo(this.x+(t*6), this.y+(t*3));
			ctx.lineTo(this.x-(t*6), this.y+(t*3));
			ctx.lineTo(this.x-(t*6), this.y-(t*3));
			ctx.closePath();
			ctx.fill();
			ctx.stroke();

			ctx.fillStyle="Green";
			ctx.beginPath();
			ctx.moveTo(this.x, this.y-(t*3));
			ctx.lineTo(this.x+(t*6), this.y-(t*5));
			ctx.lineTo(this.x+(t*6), this.y-(t*3));
			ctx.lineTo(this.x, this.y-(t*3));
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
      
			ctx.beginPath();
			ctx.moveTo(this.x, this.y+(t*3));
			ctx.lineTo(this.x+(t*6), this.y+(t*5));
			ctx.lineTo(this.x+(t*6), this.y+(t*3));
			ctx.lineTo(this.x, this.y+(t*3));
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
      
			ctx.fillStyle="Red";
			ctx.beginPath();
			ctx.lineTo(this.x+(t*6), this.y+(t*3));
			ctx.lineTo(this.x+(t*8), this.y+(t*3));
			ctx.lineTo(this.x+(t*7), this.y+(t*2));
			ctx.lineTo(this.x+(t*8), this.y+t);
			ctx.lineTo(this.x+(t*7), this.y);
			ctx.lineTo(this.x+(t*8), this.y-t);
			ctx.lineTo(this.x+(t*7), this.y-(t*2));
			ctx.lineTo(this.x+(t*8), this.y-(t*3));
			ctx.lineTo(this.x+(t*6), this.y-(t*3));
			ctx.lineTo(this.x+(t*6), this.y+(t*3));
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
      
			ctx.fillStyle="Yellow";
			circle(this.x, this.y, Math.abs(t*2.4));
			ctx.fill();
			ctx.stroke();
      
			ctx.fillStyle="White";
			circle(this.x, this.y, Math.abs(t*1.4));
			ctx.fill();
			ctx.stroke();
		}
		
		
	}
		




	
	Enemy.prototype.shoot = function() {
		shipShoots.push(new Shoot(this.x, this.y, this.xSpeed * 5, this.ySpeed * 5, false));
	}
	
	Enemy.prototype.checkCollision = function(i) {
		let left = this.x - this.w/2;
		let right = this.x + this.w/2;
		let up = this.y - this.h/2;
		let down = this.y + this.h/2;
		
		shipShoots.forEach((shoot) => {
			if(shoot.x >= left && shoot.x <= right && shoot.y >= up && shoot.y <= down && shoot.my){
				enemies.splice(i, 1);
				shipShoots.splice(shipShoots.indexOf(shoot), 1);
				score += 10;
				ship.mpPlus(5);
				booms.push(new Boom(this.x, this.y, "enemy"));
				if(random(100) > 95){
					portions.push(new Portion(this.x, this.y, plusminus()*(2 + random(3)), plusminus()*(2 + random(3))));
				}
				return true;
			}
		});
		return false;
	}
	
	function randomEnemy() {
		let type = random(4);
		if(type === 0){
			enemies.push(new Enemy(random(width), 0, ENEMY_SIZE, ENEMY_SIZE*2, 0, 2, type));
		}else if (type === 1){
			enemies.push(new Enemy(random(width), height, ENEMY_SIZE, ENEMY_SIZE*2, 0, -2, type));
		}else if (type === 2){
			enemies.push(new Enemy(0, random(height), ENEMY_SIZE*2, ENEMY_SIZE, 2, 0, type));
		}else if (type === 3){
			enemies.push(new Enemy(width, random(height), ENEMY_SIZE*2, ENEMY_SIZE, -2, 0, type));
		}
	}
	
	//boom-----------------------------------------------------------------------------------------------------------------------
	let Boom = function(x, y, type){
		this.x = x;
		this.y = y;
		this.count = 0;
		this.type = type;
		
	}
	
	Boom.prototype.draw = function(){
		if(this.type === "enemy"){
			ctx.strokeStyle = "crimson";
			ctx.lineWidth = 3;
			circle(this.x, this.y, this.count);
			ctx.stroke();
			if(this.count > 10){
				circle(this.x, this.y, this.count-10);
				ctx.stroke();
			}
		}else if(this.type === "portion"){
			ctx.font = "bold 30px Courier";
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			ctx.fillStyle = "Hotpink";	
			ctx.fillText("HP+", this.x, this.y);
		}
	}
	
	//portion--------------------------------------------------------------------------------------------------------------------
	let Portion = function(x, y, xSpeed, ySpeed){
		this.x = x;
		this.y = y;
		this.xSpeed = xSpeed;
		this.ySpeed = ySpeed;
		this.r = PORTION_SIZE;
	}
	
	Portion.prototype.draw = function(){
		let r = this.r / 20;
		ctx.fillStyle = "hotpink";
		ctx.beginPath();
		ctx.moveTo(this.x, this.y-25*r);
		ctx.arc(this.x+30*r, this.y-25*r, 30*r, 0, Math.PI, true);
		ctx.arc(this.x-30*r, this.y-25*r, 30*r, 0, Math.PI, true);
		ctx.lineTo(this.x-50*r, this.y+5*r);
		ctx.lineTo(this.x-40*r, this.y+15*r);
		ctx.lineTo(this.x, this.y+55*r);
		ctx.lineTo(this.x+40*r, this.y+15*r);
		ctx.lineTo(this.x+50*r, this.y+5*r);
		ctx.lineTo(this.x+60*r, this.y-25*r);
		ctx.closePath();
		ctx.fill();
	}
	
	Portion.prototype.move = function(){
		this.x += this.xSpeed;
		this.y += this.ySpeed;
		
		if(this.x <= 10+this.r || this.x >= width-10-this.r){
			this.xSpeed = -this.xSpeed;
		}
		if(this.y <= 10+this.r || this.y >= height-10-this.r){
			this.ySpeed = -this.ySpeed;
		}
	}
	
	
	
	
	//dot------------------------------------------------------------------------------------------------------------------------
	let Dot = function(x, y, r, color){
		this.x = x;
		this.y = y;
		this.r = r;
		this.color = color+color+color;
	}
	
	Dot.prototype.draw = function(){
		ctx.fillStyle = "#" + this.color;
		ctx.fillRect(this.x, this.y, this.r, this.r);
	}


	//set variables--------------------------------------------------------------------------------------------------------------
	
	let score = 0;
	let start = false;
	let quadtree = false;
	let boundary = new Rectangle(0, 0, width, height);
	let ship = new Ship(width/2, height/2);
	let arrow = new Arrow();
	let shipShoots = [];
	let enemies = [];
	let booms = [];
	let portions = [];
	let dots = [];
	let gachonImg = new Image();
	let arrowValue = 15;
	gachonImg.src = IMG_SRC;
	for(let i=0 ; i<250 ; i++){
		dots.push(new Dot(random(width), random(height), random(4), random(14).toString(16)));
	}
	
	
	
	//event handler--------------------------------------------------------------------------------------------------------------
	
	canvas.addEventListener("click", function (event){
		if(start){
			ship.shoot();
		}else{
			if(event.pageX > 610 && event.pageX < 910 && event.pageY > 350 && event.pageY < 400) {
				start = true;
			}
		}				
	});
	
	BODY.addEventListener("mousemove", function(event){
		let bit = Math.sqrt((event.pageX-ship.x)*(event.pageX-ship.x) + (event.pageY-ship.y)*(event.pageY-ship.y));
		ship.sin = -(event.pageY-ship.y) / bit;
		ship.cos = (event.pageX-ship.x) / bit;
	});
	
	BODY.addEventListener("keydown", function (event){
		let direction = keyActions[event.keyCode];
		ship.setDirection(direction);
	});
	
	let keyActions = {
		32: "space",
		65: "left",
		87: "up",
		68: "right",
		83: "down",
		192: "quadtree"
	};
	
	
	
	
	
	//main game functions--------------------------------------------------------------------------------------------------------
	
	let intervalId = setInterval(function() {
		if(start){
			playGame();
		} else{
			readyGame();
		}
	}, 30);
	
	function readyGame() {
		ctx.fillRect(0, 0, width, height);
		dots.forEach((dot) => {dot.draw();});
		drawBorder();
		drawLoading();
	}
	
	function playGame(){
		if(random(100) > 95){
			randomEnemy();
		}
		ctx.fillStyle = "Black";
		ctx.fillRect(0, 0, width, height);
		dots.forEach((dot) => {dot.draw();});
		activate();
		drawBorder();
		drawScore();
	}
	
	function quadtreeActivate(){
		if(quadtree){
			let qtree = new QuadTree(boundary, 1);
			qtree.refresh();
			qtree.show();
		}
	}
	
	function shootActivate(){
		for(let i=0 ; i < shipShoots.length; i++){
			shipShoots[i].move();
			shipShoots[i].draw();
			if(!shipShoots[i].use){
				if(!shipShoots[i].my){
					score++;
					ship.mp += 0.5;
					if(ship.mp >= 100){
						ship.mp = 100;
					}
				}
				shipShoots.splice(i, 1);
				i--;
			}
		}	
	}
	
	function shipActivate(ship){
		ship.move();
		ship.draw();
		ship.checkCollision();
	}
	
	function enemyActivate(){
		for(let i=0 ; i < enemies.length ; i++){
			enemies[i].move();
			enemies[i].draw();
			if(!enemies[i].use || enemies[i].checkCollision(i)){
				enemies.splice(i, 1);
				i--;
			}
		}
	}
	
	function boomActivate(){
		booms.forEach((boom)=> {
			boom.draw();
			boom.count+=5;
			if(boom.count >= 30){
				booms.splice(booms.indexOf(boom), 1);
			}
		});
	}
	
	function portionActivate(){
		portions.forEach((portion) => {
			portion.draw();
			portion.move();
		});
	} 
	
	function activate(){
		quadtreeActivate();
		shootActivate();
		shipActivate(ship);
		enemyActivate();
		boomActivate();
		portionActivate();
	}
	
	
</script>
</body>
</html>